<?php
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class AddressTable extends Doctrine_Table
{
  const OFFICE_CATEGORY = 1;
  const RESIDENCE_CATEGORY = 2;
  const MAILING_CATEGORY = 3;


  //checks for addresses matching $address.  
  //set $saved to TRUE for addresses that have already been saved to the database
  static function retrieveByAddress(Address $address, $saved = false, Entity $e = null)
  {
    $check_cols = array('street1','street2','street3','city','state_id','postal','country_id');
    $query = LsDoctrineQuery::create()
          ->from('Address a');
    if ($saved == true)
    {
      $query->addWhere('a.id != ?', $address->id);
    }
    foreach($check_cols as $check_col)
    {
      $clause = 'a.' . $check_col . ' = ?';
      $val = $address[$check_col];
      $query->addWhere($clause, $val);
    }
    if ($e)
    {
      if (!$e->exists())
      {
        throw new Exception("Given Entity must not be new");
      }
      
      $query->addWhere('a.entity_id = ?', $e->id);
    }
    $result = $query->execute()->getFirst();
    $ret = ($result) ? $result : null;

    return $ret;
  }
    
  
  static function getByCoordsQuery($longitude, $latitude, Entity $e=null)
  {
    if (!$longitude || !$latitude)
    {
      throw new Exception("Longitude and latitude must be given");
    }


    $q = LsDoctrineQuery::create()
      ->from('Address a')
      ->where('a.latitude = ? and a.longitude = ?', array($latitude, $longitude));
      
    if ($e)
    {
      if (!$e->exists())
      {
        throw new Exception("Given Entity must not be new");
      }
      
      $q->addWhere('a.entity_id = ?', $e->id);
    }
    
    return $q;
  }

    
  static function areSame(Address $a1, Address $a2)
  {
  
    if (($a1->longitude() == $a2->longitude) 
      && ($a1->latitude() == $a2->latitude())
      && $a1->longitude() && $a1->latitude())
    {
      $ret = true;
    }
    else
    {
      $text1 = $a1->getOneLiner();
      $text2 = $a2->getOneLiner();
        
      $coords1 = self::coords($text1);
      $coords2 = self::coords($text2);
    
      $ret = $coords1 && $coords2 && ($coords1 == $coords2);
    }
    
    return $ret;
  }
  
  /**
   * Uses Google Maps API to retrieve latitude & longitude for an address
   */
  static function coords($str)
  {    
    $str = preg_replace('/[\n\r]/', ' ', $str);

    $key = sfConfig::get('sf_google_maps_key');
    $url = 'http://maps.google.com/maps/geo?q=' . urlencode($str) . '&output=xml&key=' . $key;
  
    $c = new sfWebBrowser();

    if (!$c->get($url)->responseIsError())
    {
      $coords = (array) $c->getResponseXml()->Response->Placemark->Point->coordinates;
      if ($coords)
      {
        list($lon, $lat, $alt) = explode(',', $coords[0]);
        $ret = array('longitude' => $lon, 'latitude' => $lat);
      }
      else
      {
        $ret = null;
      }
    }
    else
    {
      $ret = null;
    }  

    return $ret;
  }
  
  
  static function addCoords(Address $address)
  {
    if ($coords = self::coords($address->getOneLiner()))
    {
      $address->latitude = $coords['latitude'];
      $address->longitude = $coords['longitude'];
    }
    
    return $address;  
  }
  
  
  /**
   * Uses Google Maps API to parse flat address
   */
  static function parse($str, $returnAccuracy=false)
  {
    //CLEANUP
    $str = preg_replace('/[\n\r]/', ' ', $str);

    $key = sfConfig::get('sf_google_maps_key');

    $url = 'http://maps.google.com/maps/geo?q=' . urlencode($str) . '&output=xml&key=' . $key;
    //echo $url . "\n";
    $c = new sfWebBrowser();

    try
    {
      if (!$c->get($url)->responseIsError())
      {
        $c->setResponseText(iconv('ISO-8859-1', 'UTF-8', $c->getResponseText()));

        $xml = $c->getResponseXml();
        //var_dump($xml);
        $structured = $xml->Response->Placemark->AddressDetails;
        $accuracy = (int) $structured['Accuracy'];   
      }
      else
      {
        return null;
      }
    }
    catch (Exception $e)
    {
      // Adapter error (eg. Host not found)
      throw $e;
    }

    //accuracy of 4+ means we have at least a town (UNLESS THE TOWN DOESN'T "OFFICIALLY" EXIST)
    if ($accuracy > 3)
    {
      $address = new Address;

      //COUNTRY (USA only for now)
      $address->country_id = 1;
      
      //STATE (for some reason trickery needs to be done to get state to work right)
      $stateName = null;
      if (isset($structured->Country->AdministrativeArea->AdministrativeAreaName))
      {
        $stateName = (array) $structured->Country->AdministrativeArea->AdministrativeAreaName;
        $stateName = isset($stateName[0]) ? $stateName[0] : $stateName;
      }
      else 
      {
        $possible_state = $structured->Country->CountryNameCode;
        if ($possible_state != 'US')
        {
          $stateName = $possible_state;
        }
      }

      if (!$stateName)
      {
        return null;
      }
      if (!$state = AddressStateTable::retrieveByText($stateName))
      {
        return null;
      }
      
      $address->state_id = $state->id;
      
      //COUNTY (this may not exist)
      $countyName = $structured->Country->AdministrativeArea->SubAdministrativeArea->SubAdministrativeAreaName;
      $address->county = LsString::emptyToNull((string) $countyName);
      
      if ($countyName)
      {
        $cityName = $structured->Country->AdministrativeArea->SubAdministrativeArea->Locality->LocalityName;
      }
      else
      {
        $cityName = $structured->Country->AdministrativeArea->Locality->LocalityName;
      }
            
      //CITY (this may not exist!)
      $address->city = (string) $cityName;
      
      //accuracy of 5+ means we have postal code
      if ($accuracy > 4)
      {
        if ($cityName && $countyName)
        {
          $base = $structured->Country->AdministrativeArea->SubAdministrativeArea->Locality;
          if(isset($base->DependentLocality))
          {
            $base = $base->DependentLocality;
          }
            
        }
        else if ($cityName && !$countyName)
        {
          $base = $structured->Country->AdministrativeArea->Locality;
        }
        else if (!$cityName && $countyName)
        {
          $base = $structured->Country->AdministrativeArea->SubAdministrativeArea;
        }
        else
        {
          $base = $structured->Country->AdministrativeArea;        
        }
        
        //POSTAL CODE (for some reason trickery needs to be done to get postal code to work right)
        if ($postalCode = (array) $base->PostalCode->PostalCodeNumber)
        {
          $postalCode = $postalCode[0];
          $address->postal = (string) $postalCode;
        }

        //accuracy of 8 means we have exact match
        //echo $accuracy . "\n";
        if ($accuracy > 5)
        {
          //STREET (unit info is lost)
          //echo "street1 info found \n";
          $street1 = $base->Thoroughfare->ThoroughfareName;
          $address->street1 = (string) $street1;
        }
      }

      //COORDINATES
      // Parse the coordinate string
      $coords = $c->getResponseXml()->Response->Placemark->Point->coordinates;
      list($lon, $lat, $alt) = explode(",", $coords);
      $address->longitude = $lon;
      $address->latitude = $lat;


      if ($returnAccuracy)
      {
        return array('address' => $address, 'accuracy' => $accuracy);
      }
      else
      {
        return $address;
      }
    }
    else
    {
      return null;
    }
  }
  
  static function parseV3($str)
  {
    $str = preg_replace('/[\n\r]/', ' ', $str);


    $url = 'http://maps.googleapis.com/maps/api/geocode/json?sensor=false&address=' . urlencode($str);
    $c = new sfWebBrowser();

    try
    {
      if (!$c->get($url)->responseIsError())
      {
        $c->setResponseText(iconv('ISO-8859-1', 'UTF-8', $c->getResponseText()));

        $json = $c->getResponseText();
        $result = json_decode($json,true);  
      }
      else
      {
        return null;
      }
    }
    catch (Exception $e)
    {
      // Adapter error (eg. Host not found)
      throw $e;
    }
    
    if ($result['status'] == 'OK')
    {
      $address = self::parseGeoArray($result);
      return $address;
    }
    else return false;
  
  }

  static function parseGeoArray($arr)
  {
    $raw_address = $arr['results'][0];
    $address = new Address;

    //COUNTRY (USA only for now)
    $address->country_id = 1;
    
    foreach($raw_address['address_components'] as $component)
    {
      switch ($component['types']) {
        case in_array('postal_code',$component['types']):
          $address->postal = $component['long_name'];
          break;
        case in_array('administrative_area_level_1',$component['types']):
          if ($state = AddressStateTable::retrieveByText($component['long_name']))
          {
            $address->state_id = $state->id;
          }
          break;
        case in_array('administrative_area_level_2',$component['types']):
          $address->county = $component['long_name'];
          break;
        case in_array('administrative_area_level_3',$component['types']):
          $admin_area_3 = $component['long_name'];
          break;
        case in_array('locality',$component['types']):
          $locality = $component['long_name'];
          break;
        case in_array('sublocality',$component['types']):
          $sublocality = $component['long_name'];
          break;
        case in_array('route',$component['types']):
          $street = $component['long_name'];
          break;
        case in_array('street_number',$component['types']):
          $street_number = $component['long_name'];
          break;
        case in_array('subpremise',$component['types']):
          $address->street2 = $component['long_name'];
          break;
        default:
          break;
      }
    }
    if (isset($locality) && isset($sublocality))
    {
      if ($locality == 'New York' && $sublocality != 'Manhattan' ) $address->city = $sublocality;
      else $address->city = $locality;
      
    }
    else if (isset($locality))
    {
      $address->city = $locality;    
    }
    else if (isset($admin_area_3))
    {
      $address->city = $admin_area_3;
    }
    if (isset($street) && isset($street_number))
    {
      $address->street1 = $street_number . " " . $street;
    }

    $address->latitude = $raw_address['geometry']['location']['lat'];
    $address->longitude = $raw_address['geometry']['location']['lng'];
    sleep(1); 
    return $address;
  }

  static function standardize($address)
  {
    $attempts = array();

    //if given an Address, we'll attempt to standardize it with Google
    //by isolating any of the up-to-3 street addresses it may have
    if ($address instanceOf Address)
    {
      $clone = clone $address;
      $clone->street2 = null;
      $clone->street3 = null;     
      $attempts[] = $clone->getOneLiner();
          
      if (preg_match('/^(\d+\s+[^\,]*)\,(.*)$/isu',$address->street1,$match))
      {
        $clone = clone $address;
        $clone->street1 = $match[1];
        $clone->street2 = null;
        $clone->street3 = null;     
        $attempts[] = $clone->getOneLiner();
      }   
      else if (preg_match('/^(\d+\s+[^\,]*)\,(.*)$/isu',$address->street2,$match))
      {
        $clone = clone $address;
        $clone->street1 = $match[1];
        $clone->street2 = null;
        $clone->street3 = null;
        $attempts[] = $clone->getOneLiner();
      }
          
      if ($address->street2)
      {
        $clone = clone $address;
        $clone->street1 = $address->street2;
        $clone->street2 = null;
        $clone->street3 = null;        
        $attempts[] = $clone->getOneLiner();
      }
      
      if ($address->street3)
      {
        $clone = clone $address;
        $clone->street1 = $address->street3;
        $clone->street2 = null;
        $clone->street3 = null;        
        $attempts[] = $clone->getOneLiner();
      }

      $cityClone = clone $address;
      $cityClone->street1 = null;
      $cityClone->street2 = null;
      $cityClone->street3 = null;     
      $cityClone->postal = null;
    }
    else
    {
      $attempts[] = $address;
    }

    $bestClone = null;
    $bestAccuracy = 0;
    
    if (isset($cityClone))
    {
      $cityResult = self::parse($cityClone->getOneLiner(), $returnAccuracy=true);
    }

    foreach ($attempts as $attempt)
    {
      if ($result = self::parse($attempt, $returnAccuracy=true))
      {
        $parsed = $result['address'];
        $accuracy = $result['accuracy'];

        if ($parsed->city && $accuracy > $bestAccuracy)
        {
          if ((isset($cityResult) && $cityResult['accuracy'] > 2 && $cityResult['address']->city == $parsed->city) || !isset($cityResult) || !$cityResult['address']->city || $address->postal == substr(trim($parsed->postal),0,5))
          { 
            $bestAccuracy = $accuracy;
            $bestClone = $parsed;
          }
        }
      }
    }

    if ($bestClone)
    {
      if ($address instanceof Address)
      {
        $address->postal = substr(trim($bestClone->postal),0,5);
        $address->city = $bestClone->city;
        $address->county = $bestClone->county;
        $address->state_id = $bestClone->state_id;
        $address->latitude = $bestClone->latitude;
        $address->longitude = $bestClone->longitude;
        $address->country_id = $bestClone->country_id;
        
        return $address;
      }
      $bestClone->postal = substr(trim($bestClone->postal),0,5);
      return $bestClone;
    }
    
    if ($address instanceOf Address)
    {
      $address->postal = substr(trim($address->postal),0,5);
      return $address;
    }
    
    return null;
  }
  
  
  static function getAdvancedSearchQuery(
    $street1 = null,
    $street2 = null,
    $street3 = null,
    $city = null,
    $county = null,
    $state_id = null,
    $postal = null,
    $country_id = null,
    $latitude = null,
    $latitude_range = null,
    $longitude = null,
    $longitude_range = null)
  {
    $q = LsDoctrineQuery::create()
        ->from('Address a');
     
  
    if ($street1)
    {
      $q->addWhere('a.street1 LIKE ? OR a.street2 LIKE ? OR a.street3 LIKE ?', array(
        '%' . $street1 . '%',
        '%' . $street1 . '%',
        '%' . $street1 . '%'        
      ));
    }

    if ($street2)
    {
      $q->addWhere('a.street1 LIKE ? OR a.street2 LIKE ? OR a.street3 LIKE ?', array(
        '%' . $street2 . '%',
        '%' . $street2 . '%',
        '%' . $street2 . '%'        
      ));
    }

    if ($city)
    {
      $q->addWhere('a.city LIKE ?', '%' . $city . '%');
    }
    
    if ($county)
    {
      $q->addWhere('a.county LIKE ?', '%' . $county . '%');
    }
    
    if ($state_id)
    {
      $q->addWhere('a.state_id = ?', $state_id);
    }
    
    if ($postal)
    {
      $q->addWhere('a.postal = ?', $postal);
    }

    if ($country_id)
    {
      $q->addWhere('a.country_id = ?', $country_id);
    }
    
    if ($longitude)
    {
      $range = !is_null($longitude_range) ? $longitude_range : '0.5';
      $q->addWhere('a.longitude < ? and a.longitude > ?', array($longitude + $range, $longitude - $range));
    }

    if ($latitude)
    {
      $range = !is_null($latitude_range) ? $latitude_range : '0.5';
      $q->addWhere('a.latitude < ? and a.latitude > ?', array($latitude + $range, $latitude - $range));
    }


    //avoid search with no conditions
    if (count($q->getDqlPart('where')) == 0)
    {
      $q->addWhere('1 = 0');
    }


    return $q;  
  }
  
  
  static function getDistanceBetweenCoords($lat1, $lon1, $lat2, $lon2, $unit='M')
  {
    if (!$lat1 || !$lon1 || !$lat2 || !$lon2)
    {
      return null;
    }

    
    $theta = $lon1 - $lon2; 
    $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta)); 
    $dist = acos($dist); 
    $dist = rad2deg($dist); 
    $miles = $dist * 60 * 1.1515;
    $unit = strtoupper($unit);
  
    if ($unit == 'K') 
    {
      return ($miles * 1.609344); 
    } 
    else if ($unit == 'N')
    {
      return ($miles * 0.8684);
    } 
    else 
    {
      return $miles;
    }
  }  
}
